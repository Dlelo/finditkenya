'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const fs = require('fs');
const path = require('path');
const debug = require('debug')('email-templates');
const htmlToText = require('html-to-text');
const I18N = require('@ladjs/i18n');
const autoBind = require('auto-bind');
const nodemailer = require('nodemailer');
const consolidate = require('consolidate');
const previewEmail = require('preview-email');
const _ = require('lodash');
const Promise = require('bluebird');

const getPaths = require('get-paths');
const juiceResources = require('juice-resources-promise');

const env = process.env.NODE_ENV || 'development';
const stat = Promise.promisify(fs.stat);
const readFile = Promise.promisify(fs.readFile);

class Email {
  constructor(config = {}) {
    debug('config passed %O', config);

    // 2.x backwards compatible support
    if (config.juiceOptions) {
      config.juiceResources = config.juiceOptions;
      delete config.juiceOptions;
    }
    if (config.disableJuice) {
      config.juice = false;
      delete config.disableJuice;
    }
    if (config.render) {
      config.customRender = true;
    }

    this.config = _.merge({
      views: {
        // directory where email templates reside
        root: path.resolve('emails'),
        options: {
          // default file extension for template
          extension: 'pug',
          map: {
            hbs: 'handlebars',
            njk: 'nunjucks'
          },
          engineSource: consolidate
        },
        // locals to pass to templates for rendering
        locals: {
          // pretty is automatically set to `false` for subject/text
          pretty: true
        }
      },
      // <https://nodemailer.com/message/>
      message: {},
      send: !['development', 'test'].includes(env),
      preview: env === 'development',
      // <https://github.com/ladjs/i18n>
      // set to an object to configure and enable it
      i18n: false,
      // pass a custom render function if necessary
      render: this.render.bind(this),
      customRender: false,
      // force text-only rendering of template (disregards template folder)
      textOnly: false,
      // <https://github.com/werk85/node-html-to-text>
      htmlToText: {
        ignoreImage: true
      },
      subjectPrefix: false,
      // <https://github.com/Automattic/juice>
      juice: true,
      juiceResources: {
        preserveImportant: true,
        webResources: {
          relativeTo: path.resolve('build'),
          images: false
        }
      },
      // pass a transport configuration object or a transport instance
      // (e.g. an instance is created via `nodemailer.createTransport`)
      // <https://nodemailer.com/transports/>
      transport: {}
    }, config);

    // override existing method
    this.render = this.config.render;

    if (!_.isFunction(this.config.transport.sendMail)) this.config.transport = nodemailer.createTransport(this.config.transport);

    debug('transformed config %O', this.config);

    autoBind(this);
  }

  // shorthand use of `juiceResources` with the config
  // (mainly for custom renders like from a database)
  juiceResources(html) {
    return juiceResources(html, this.config.juiceResources);
  }

  // a simple helper function that gets the actual file path for the template
  getTemplatePath(view) {
    var _this = this;

    return new Promise((() => {
      var _ref = _asyncToGenerator(function* (resolve, reject) {
        try {
          const paths = yield getPaths(_this.config.views.root, view, _this.config.views.options.extension);
          const filePath = path.resolve(_this.config.views.root, paths.rel);
          resolve({ filePath, paths });
        } catch (err) {
          reject(err);
        }
      });

      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    })());
  }

  // returns true or false if a template exists
  // (uses same look-up approach as `render` function)
  templateExists(view) {
    var _this2 = this;

    return new Promise((() => {
      var _ref2 = _asyncToGenerator(function* (resolve) {
        try {
          var _ref3 = yield _this2.getTemplatePath(view);

          const filePath = _ref3.filePath;

          const stats = yield stat(filePath);
          if (!stats.isFile()) throw new Error(`${filePath} was not a file`);
          resolve(true);
        } catch (err) {
          debug('templateExists', err);
          resolve(false);
        }
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    })());
  }

  // promise version of consolidate's render
  // inspired by koa-views and re-uses the same config
  // <https://github.com/queckezz/koa-views>
  render(view, locals = {}) {
    var _this3 = this;

    return new Promise((() => {
      var _ref4 = _asyncToGenerator(function* (resolve, reject) {
        try {
          var _config$views$options = _this3.config.views.options;
          const map = _config$views$options.map,
                engineSource = _config$views$options.engineSource;

          var _ref5 = yield _this3.getTemplatePath(view);

          const filePath = _ref5.filePath,
                paths = _ref5.paths;

          if (paths.ext === 'html' && !map) {
            const res = yield readFile(filePath, 'utf8');
            resolve(res);
          } else {
            const engineName = map && map[paths.ext] ? map[paths.ext] : paths.ext;
            const renderFn = engineSource[engineName];
            if (!engineName || !renderFn) return reject(new Error(`Engine not found for the ".${paths.ext}" file extension`));

            if (_.isObject(_this3.config.i18n)) {
              const i18n = new I18N(Object.assign({}, _this3.config.i18n, {
                register: locals
              }));

              // support `locals.user.last_locale`
              // (e.g. for <https://lad.js.org>)
              if (_.isObject(locals.user) && _.isString(locals.user.last_locale)) locals.locale = locals.user.last_locale;

              if (_.isString(locals.locale)) i18n.setLocale(locals.locale);
            }

            // TODO: convert this to a promise based version
            renderFn(filePath, locals, function (err, res) {
              if (err) return reject(err);
              // transform the html with juice using remote paths
              // google now supports media queries
              // https://developers.google.com/gmail/design/reference/supported_css
              if (!_this3.config.juice) return resolve(res);
              _this3.juiceResources(res).then(resolve).catch(reject);
            });
          }
        } catch (err) {
          reject(err);
        }
      });

      return function (_x4, _x5) {
        return _ref4.apply(this, arguments);
      };
    })());
  }

  renderAll(template, locals = {}, message = {}) {
    var _this4 = this;

    return new Promise((() => {
      var _ref6 = _asyncToGenerator(function* (resolve, reject) {
        try {
          let subjectTemplateExists = _this4.config.customRender;
          let htmlTemplateExists = _this4.config.customRender;
          let textTemplateExists = _this4.config.customRender;

          const promises = [_this4.templateExists(`${template}/subject`), _this4.templateExists(`${template}/html`), _this4.templateExists(`${template}/text`)];

          if (template && !_this4.config.customRender) {
            ;

            var _ref7 = yield Promise.all(promises);

            var _ref8 = _slicedToArray(_ref7, 3);

            subjectTemplateExists = _ref8[0];
            htmlTemplateExists = _ref8[1];
            textTemplateExists = _ref8[2];
          }if (!message.subject && subjectTemplateExists) {
            message.subject = yield _this4.render(`${template}/subject`, Object.assign({}, locals, { pretty: false }));
            message.subject = message.subject.trim();
          }

          if (message.subject && _this4.config.subjectPrefix) message.subject = _this4.config.subjectPrefix + message.subject;

          if (!message.html && htmlTemplateExists) message.html = yield _this4.render(`${template}/html`, locals);

          if (!message.text && textTemplateExists) message.text = yield _this4.render(`${template}/text`, Object.assign({}, locals, { pretty: false }));

          if (_this4.config.htmlToText && message.html && !message.text)
            // we'd use nodemailer-html-to-text plugin
            // but we really don't need to support cid
            // <https://github.com/andris9/nodemailer-html-to-text>
            message.text = htmlToText.fromString(message.html, _this4.config.htmlToText);

          // if we only want a text-based version of the email
          if (_this4.config.textOnly) delete message.html;

          resolve(message);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x6, _x7) {
        return _ref6.apply(this, arguments);
      };
    })());
  }

  send(options = {}) {
    var _this5 = this;

    options = Object.assign({
      template: '',
      message: {},
      locals: {}
    }, options);

    var _options = options;
    let template = _options.template,
        message = _options.message,
        locals = _options.locals;


    const attachments = message.attachments || this.config.message.attachments || [];

    message = _.defaultsDeep({}, _.omit(this.config.message, 'attachments'), _.omit(message, 'attachments'));
    locals = _.defaultsDeep({}, this.config.views.locals, locals);

    if (attachments) message.attachments = attachments;

    debug('template %s', template);
    debug('message %O', message);
    debug('locals (keys only): %O', Object.keys(locals));

    return new Promise((() => {
      var _ref9 = _asyncToGenerator(function* (resolve, reject) {
        try {
          // get all available templates
          const obj = yield _this5.renderAll(template, locals, message);

          // assign the object variables over to the message
          Object.assign(message, obj);

          if (_this5.config.preview) {
            debug('using `preview-email` to preview email');
            yield previewEmail(message);
          }

          if (!_this5.config.send) {
            debug('send disabled so we are ensuring JSONTransport');
            // <https://github.com/nodemailer/nodemailer/issues/798>
            // if (this.config.transport.name !== 'JSONTransport')
            _this5.config.transport = nodemailer.createTransport({
              jsonTransport: true
            });
          }

          const res = yield _this5.config.transport.sendMail(message);
          debug('message sent');
          res.originalMessage = message;
          resolve(res);
        } catch (err) {
          reject(err);
        }
      });

      return function (_x8, _x9) {
        return _ref9.apply(this, arguments);
      };
    })());
  }
}

module.exports = Email;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9pbmRleC5qcyJdLCJuYW1lcyI6WyJmcyIsInJlcXVpcmUiLCJwYXRoIiwiZGVidWciLCJodG1sVG9UZXh0IiwiSTE4TiIsImF1dG9CaW5kIiwibm9kZW1haWxlciIsImNvbnNvbGlkYXRlIiwicHJldmlld0VtYWlsIiwiXyIsIlByb21pc2UiLCJnZXRQYXRocyIsImp1aWNlUmVzb3VyY2VzIiwiZW52IiwicHJvY2VzcyIsIk5PREVfRU5WIiwic3RhdCIsInByb21pc2lmeSIsInJlYWRGaWxlIiwiRW1haWwiLCJjb25zdHJ1Y3RvciIsImNvbmZpZyIsImp1aWNlT3B0aW9ucyIsImRpc2FibGVKdWljZSIsImp1aWNlIiwicmVuZGVyIiwiY3VzdG9tUmVuZGVyIiwibWVyZ2UiLCJ2aWV3cyIsInJvb3QiLCJyZXNvbHZlIiwib3B0aW9ucyIsImV4dGVuc2lvbiIsIm1hcCIsImhicyIsIm5qayIsImVuZ2luZVNvdXJjZSIsImxvY2FscyIsInByZXR0eSIsIm1lc3NhZ2UiLCJzZW5kIiwiaW5jbHVkZXMiLCJwcmV2aWV3IiwiaTE4biIsImJpbmQiLCJ0ZXh0T25seSIsImlnbm9yZUltYWdlIiwic3ViamVjdFByZWZpeCIsInByZXNlcnZlSW1wb3J0YW50Iiwid2ViUmVzb3VyY2VzIiwicmVsYXRpdmVUbyIsImltYWdlcyIsInRyYW5zcG9ydCIsImlzRnVuY3Rpb24iLCJzZW5kTWFpbCIsImNyZWF0ZVRyYW5zcG9ydCIsImh0bWwiLCJnZXRUZW1wbGF0ZVBhdGgiLCJ2aWV3IiwicmVqZWN0IiwicGF0aHMiLCJmaWxlUGF0aCIsInJlbCIsImVyciIsInRlbXBsYXRlRXhpc3RzIiwic3RhdHMiLCJpc0ZpbGUiLCJFcnJvciIsImV4dCIsInJlcyIsImVuZ2luZU5hbWUiLCJyZW5kZXJGbiIsImlzT2JqZWN0IiwiT2JqZWN0IiwiYXNzaWduIiwicmVnaXN0ZXIiLCJ1c2VyIiwiaXNTdHJpbmciLCJsYXN0X2xvY2FsZSIsImxvY2FsZSIsInNldExvY2FsZSIsInRoZW4iLCJjYXRjaCIsInJlbmRlckFsbCIsInRlbXBsYXRlIiwic3ViamVjdFRlbXBsYXRlRXhpc3RzIiwiaHRtbFRlbXBsYXRlRXhpc3RzIiwidGV4dFRlbXBsYXRlRXhpc3RzIiwicHJvbWlzZXMiLCJhbGwiLCJzdWJqZWN0IiwidHJpbSIsInRleHQiLCJmcm9tU3RyaW5nIiwiYXR0YWNobWVudHMiLCJkZWZhdWx0c0RlZXAiLCJvbWl0Iiwia2V5cyIsIm9iaiIsImpzb25UcmFuc3BvcnQiLCJvcmlnaW5hbE1lc3NhZ2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxNQUFNQSxLQUFLQyxRQUFRLElBQVIsQ0FBWDtBQUNBLE1BQU1DLE9BQU9ELFFBQVEsTUFBUixDQUFiO0FBQ0EsTUFBTUUsUUFBUUYsUUFBUSxPQUFSLEVBQWlCLGlCQUFqQixDQUFkO0FBQ0EsTUFBTUcsYUFBYUgsUUFBUSxjQUFSLENBQW5CO0FBQ0EsTUFBTUksT0FBT0osUUFBUSxhQUFSLENBQWI7QUFDQSxNQUFNSyxXQUFXTCxRQUFRLFdBQVIsQ0FBakI7QUFDQSxNQUFNTSxhQUFhTixRQUFRLFlBQVIsQ0FBbkI7QUFDQSxNQUFNTyxjQUFjUCxRQUFRLGFBQVIsQ0FBcEI7QUFDQSxNQUFNUSxlQUFlUixRQUFRLGVBQVIsQ0FBckI7QUFDQSxNQUFNUyxJQUFJVCxRQUFRLFFBQVIsQ0FBVjtBQUNBLE1BQU1VLFVBQVVWLFFBQVEsVUFBUixDQUFoQjs7QUFFQSxNQUFNVyxXQUFXWCxRQUFRLFdBQVIsQ0FBakI7QUFDQSxNQUFNWSxpQkFBaUJaLFFBQVEseUJBQVIsQ0FBdkI7O0FBRUEsTUFBTWEsTUFBTUMsUUFBUUQsR0FBUixDQUFZRSxRQUFaLElBQXdCLGFBQXBDO0FBQ0EsTUFBTUMsT0FBT04sUUFBUU8sU0FBUixDQUFrQmxCLEdBQUdpQixJQUFyQixDQUFiO0FBQ0EsTUFBTUUsV0FBV1IsUUFBUU8sU0FBUixDQUFrQmxCLEdBQUdtQixRQUFyQixDQUFqQjs7QUFFQSxNQUFNQyxLQUFOLENB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Iiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW1haWwtdGVtcGxhdGVzJyk7XG5jb25zdCBodG1sVG9UZXh0ID0gcmVxdWlyZSgnaHRtbC10by10ZXh0Jyk7XG5jb25zdCBJMThOID0gcmVxdWlyZSgnQGxhZGpzL2kxOG4nKTtcbmNvbnN0IGF1dG9CaW5kID0gcmVxdWlyZSgnYXV0by1iaW5kJyk7XG5jb25zdCBub2RlbWFpbGVyID0gcmVxdWlyZSgnbm9kZW1haWxlcicpO1xuY29uc3QgY29uc29saWRhdGUgPSByZXF1aXJlKCdjb25zb2xpZGF0ZScpO1xuY29uc3QgcHJldmlld0VtYWlsID0gcmVxdWlyZSgncHJldmlldy1lbWFpbCcpO1xuY29uc3QgXyA9IHJlcXVpcmUoJ2xvZGFzaCcpO1xuY29uc3QgUHJvbWlzZSA9IHJlcXVpcmUoJ2JsdWViaXJkJyk7XG5cbmNvbnN0IGdldFBhdGhzID0gcmVxdWlyZSgnZ2V0LXBhdGhzJyk7XG5jb25zdCBqdWljZVJlc291cmNlcyA9IHJlcXVpcmUoJ2p1aWNlLXJlc291cmNlcy1wcm9taXNlJyk7XG5cbmNvbnN0IGVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WIHx8ICdkZXZlbG9wbWVudCc7XG5jb25zdCBzdGF0ID0gUHJvbWlzZS5wcm9taXNpZnkoZnMuc3RhdCk7XG5jb25zdCByZWFkRmlsZSA9IFByb21pc2UucHJvbWlzaWZ5KGZzLnJlYWRGaWxlKTtcblxuY2xhc3MgRW1haWwge1xuICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgIGRlYnVnKCdjb25maWcgcGFzc2VkICVPJywgY29uZmlnKTtcblxuICAgIC8vIDIueCBiYWNrd2FyZHMgY29tcGF0aWJsZSBzdXBwb3J0XG4gICAgaWYgKGNvbmZpZy5qdWljZU9wdGlvbnMpIHtcbiAgICAgIGNvbmZpZy5qdWljZVJlc291cmNlcyA9IGNvbmZpZy5qdWljZU9wdGlvbnM7XG4gICAgICBkZWxldGUgY29uZmlnLmp1aWNlT3B0aW9ucztcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5kaXNhYmxlSnVpY2UpIHtcbiAgICAgIGNvbmZpZy5qdWljZSA9IGZhbHNlO1xuICAgICAgZGVsZXRlIGNvbmZpZy5kaXNhYmxlSnVpY2U7XG4gICAgfVxuICAgIGlmIChjb25maWcucmVuZGVyKSB7XG4gICAgICBjb25maWcuY3VzdG9tUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbmZpZyA9IF8ubWVyZ2UoXG4gICAgICB7XG4gICAgICAgIHZpZXdzOiB7XG4gICAgICAgICAgLy8gZGlyZWN0b3J5IHdoZXJlIGVtYWlsIHRlbXBsYXRlcyByZXNpZGVcbiAgICAgICAgICByb290OiBwYXRoLnJlc29sdmUoJ2VtYWlscycpLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8vIGRlZmF1bHQgZmlsZSBleHRlbnNpb24gZm9yIHRlbXBsYXRlXG4gICAgICAgICAgICBleHRlbnNpb246ICdwdWcnLFxuICAgICAgICAgICAgbWFwOiB7XG4gICAgICAgICAgICAgIGhiczogJ2hhbmRsZWJhcnMnLFxuICAgICAgICAgICAgICBuams6ICdudW5qdWNrcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmdpbmVTb3VyY2U6IGNvbnNvbGlkYXRlXG4gICAgICAgICAgfSxcbiAgICAgICAgICAvLyBsb2NhbHMgdG8gcGFzcyB0byB0ZW1wbGF0ZXMgZm9yIHJlbmRlcmluZ1xuICAgICAgICAgIGxvY2Fsczoge1xuICAgICAgICAgICAgLy8gcHJldHR5IGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGBmYWxzZWAgZm9yIHN1YmplY3QvdGV4dFxuICAgICAgICAgICAgcHJldHR5OiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyA8aHR0cHM6Ly9ub2RlbWFpbGVyLmNvbS9tZXNzYWdlLz5cbiAgICAgICAgbWVzc2FnZToge30sXG4gICAgICAgIHNlbmQ6ICFbJ2RldmVsb3BtZW50JywgJ3Rlc3QnXS5pbmNsdWRlcyhlbnYpLFxuICAgICAgICBwcmV2aWV3OiBlbnYgPT09ICdkZXZlbG9wbWVudCcsXG4gICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbGFkanMvaTE4bj5cbiAgICAgICAgLy8gc2V0IHRvIGFuIG9iamVjdCB0byBjb25maWd1cmUgYW5kIGVuYWJsZSBpdFxuICAgICAgICBpMThuOiBmYWxzZSxcbiAgICAgICAgLy8gcGFzcyBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gaWYgbmVjZXNzYXJ5XG4gICAgICAgIHJlbmRlcjogdGhpcy5yZW5kZXIuYmluZCh0aGlzKSxcbiAgICAgICAgY3VzdG9tUmVuZGVyOiBmYWxzZSxcbiAgICAgICAgLy8gZm9yY2UgdGV4dC1vbmx5IHJlbmRlcmluZyBvZiB0ZW1wbGF0ZSAoZGlzcmVnYXJkcyB0ZW1wbGF0ZSBmb2xkZXIpXG4gICAgICAgIHRleHRPbmx5OiBmYWxzZSxcbiAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS93ZXJrODUvbm9kZS1odG1sLXRvLXRleHQ+XG4gICAgICAgIGh0bWxUb1RleHQ6IHtcbiAgICAgICAgICBpZ25vcmVJbWFnZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBzdWJqZWN0UHJlZml4OiBmYWxzZSxcbiAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2p1aWNlPlxuICAgICAgICBqdWljZTogdHJ1ZSxcbiAgICAgICAganVpY2VSZXNvdXJjZXM6IHtcbiAgICAgICAgICBwcmVzZXJ2ZUltcG9ydGFudDogdHJ1ZSxcbiAgICAgICAgICB3ZWJSZXNvdXJjZXM6IHtcbiAgICAgICAgICAgIHJlbGF0aXZlVG86IHBhdGgucmVzb2x2ZSgnYnVpbGQnKSxcbiAgICAgICAgICAgIGltYWdlczogZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIHBhc3MgYSB0cmFuc3BvcnQgY29uZmlndXJhdGlvbiBvYmplY3Qgb3IgYSB0cmFuc3BvcnQgaW5zdGFuY2VcbiAgICAgICAgLy8gKGUuZy4gYW4gaW5zdGFuY2UgaXMgY3JlYXRlZCB2aWEgYG5vZGVtYWlsZXIuY3JlYXRlVHJhbnNwb3J0YClcbiAgICAgICAgLy8gPGh0dHBzOi8vbm9kZW1haWxlci5jb20vdHJhbnNwb3J0cy8+XG4gICAgICAgIHRyYW5zcG9ydDoge31cbiAgICAgIH0sXG4gICAgICBjb25maWdcbiAgICApO1xuXG4gICAgLy8gb3ZlcnJpZGUgZXhpc3RpbmcgbWV0aG9kXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLmNvbmZpZy5yZW5kZXI7XG5cbiAgICBpZiAoIV8uaXNGdW5jdGlvbih0aGlzLmNvbmZpZy50cmFuc3BvcnQuc2VuZE1haWwpKVxuICAgICAgdGhpcy5jb25maWcudHJhbnNwb3J0ID0gbm9kZW1haWxlci5jcmVhdGVUcmFuc3BvcnQodGhpcy5jb25maWcudHJhbnNwb3J0KTtcblxuICAgIGRlYnVnKCd0cmFuc2Zvcm1lZCBjb25maWcgJU8nLCB0aGlzLmNvbmZpZyk7XG5cbiAgICBhdXRvQmluZCh0aGlzKTtcbiAgfVxuXG4gIC8vIHNob3J0aGFuZCB1c2Ugb2YgYGp1aWNlUmVzb3VyY2VzYCB3aXRoIHRoZSBjb25maWdcbiAgLy8gKG1haW5seSBmb3IgY3VzdG9tIHJlbmRlcnMgbGlrZSBmcm9tIGEgZGF0YWJhc2UpXG4gIGp1aWNlUmVzb3VyY2VzKGh0bWwpIHtcbiAgICByZXR1cm4ganVpY2VSZXNvdXJjZXMoaHRtbCwgdGhpcy5jb25maWcuanVpY2VSZXNvdXJjZXMpO1xuICB9XG5cbiAgLy8gYSBzaW1wbGUgaGVscGVyIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYWN0dWFsIGZpbGUgcGF0aCBmb3IgdGhlIHRlbXBsYXRlXG4gIGdldFRlbXBsYXRlUGF0aCh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhdGhzID0gYXdhaXQgZ2V0UGF0aHMoXG4gICAgICAgICAgdGhpcy5jb25maWcudmlld3Mucm9vdCxcbiAgICAgICAgICB2aWV3LFxuICAgICAgICAgIHRoaXMuY29uZmlnLnZpZXdzLm9wdGlvbnMuZXh0ZW5zaW9uXG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMuY29uZmlnLnZpZXdzLnJvb3QsIHBhdGhzLnJlbCk7XG4gICAgICAgIHJlc29sdmUoeyBmaWxlUGF0aCwgcGF0aHMgfSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyByZXR1cm5zIHRydWUgb3IgZmFsc2UgaWYgYSB0ZW1wbGF0ZSBleGlzdHNcbiAgLy8gKHVzZXMgc2FtZSBsb29rLXVwIGFwcHJvYWNoIGFzIGByZW5kZXJgIGZ1bmN0aW9uKVxuICB0ZW1wbGF0ZUV4aXN0cyh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIHJlc29sdmUgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBmaWxlUGF0aCB9ID0gYXdhaXQgdGhpcy5nZXRUZW1wbGF0ZVBhdGgodmlldyk7XG4gICAgICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgc3RhdChmaWxlUGF0aCk7XG4gICAgICAgIGlmICghc3RhdHMuaXNGaWxlKCkpIHRocm93IG5ldyBFcnJvcihgJHtmaWxlUGF0aH0gd2FzIG5vdCBhIGZpbGVgKTtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBkZWJ1ZygndGVtcGxhdGVFeGlzdHMnLCBlcnIpO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vIHByb21pc2UgdmVyc2lvbiBvZiBjb25zb2xpZGF0ZSdzIHJlbmRlclxuICAvLyBpbnNwaXJlZCBieSBrb2Etdmlld3MgYW5kIHJlLXVzZXMgdGhlIHNhbWUgY29uZmlnXG4gIC8vIDxodHRwczovL2dpdGh1Yi5jb20vcXVlY2tlenova29hLXZpZXdzPlxuICByZW5kZXIodmlldywgbG9jYWxzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgeyBtYXAsIGVuZ2luZVNvdXJjZSB9ID0gdGhpcy5jb25maWcudmlld3Mub3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBmaWxlUGF0aCwgcGF0aHMgfSA9IGF3YWl0IHRoaXMuZ2V0VGVtcGxhdGVQYXRoKHZpZXcpO1xuICAgICAgICBpZiAocGF0aHMuZXh0ID09PSAnaHRtbCcgJiYgIW1hcCkge1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHJlYWRGaWxlKGZpbGVQYXRoLCAndXRmOCcpO1xuICAgICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbmdpbmVOYW1lID0gbWFwICYmIG1hcFtwYXRocy5leHRdID8gbWFwW3BhdGhzLmV4dF0gOiBwYXRocy5leHQ7XG4gICAgICAgICAgY29uc3QgcmVuZGVyRm4gPSBlbmdpbmVTb3VyY2VbZW5naW5lTmFtZV07XG4gICAgICAgICAgaWYgKCFlbmdpbmVOYW1lIHx8ICFyZW5kZXJGbilcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgRW5naW5lIG5vdCBmb3VuZCBmb3IgdGhlIFwiLiR7cGF0aHMuZXh0fVwiIGZpbGUgZXh0ZW5zaW9uYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKF8uaXNPYmplY3QodGhpcy5jb25maWcuaTE4bikpIHtcbiAgICAgICAgICAgIGNvbnN0IGkxOG4gPSBuZXcgSTE4TihcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jb25maWcuaTE4biwge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyOiBsb2NhbHNcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgYGxvY2Fscy51c2VyLmxhc3RfbG9jYWxlYFxuICAgICAgICAgICAgLy8gKGUuZy4gZm9yIDxodHRwczovL2xhZC5qcy5vcmc+KVxuICAgICAgICAgICAgaWYgKF8uaXNPYmplY3QobG9jYWxzLnVzZXIpICYmIF8uaXNTdHJpbmcobG9jYWxzLnVzZXIubGFzdF9sb2NhbGUpKVxuICAgICAgICAgICAgICBsb2NhbHMubG9jYWxlID0gbG9jYWxzLnVzZXIubGFzdF9sb2NhbGU7XG5cbiAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKGxvY2Fscy5sb2NhbGUpKSBpMThuLnNldExvY2FsZShsb2NhbHMubG9jYWxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPOiBjb252ZXJ0IHRoaXMgdG8gYSBwcm9taXNlIGJhc2VkIHZlcnNpb25cbiAgICAgICAgICByZW5kZXJGbihmaWxlUGF0aCwgbG9jYWxzLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgIC8vIHRyYW5zZm9ybSB0aGUgaHRtbCB3aXRoIGp1aWNlIHVzaW5nIHJlbW90ZSBwYXRoc1xuICAgICAgICAgICAgLy8gZ29vZ2xlIG5vdyBzdXBwb3J0cyBtZWRpYSBxdWVyaWVzXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9nbWFpbC9kZXNpZ24vcmVmZXJlbmNlL3N1cHBvcnRlZF9jc3NcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWcuanVpY2UpIHJldHVybiByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB0aGlzLmp1aWNlUmVzb3VyY2VzKHJlcylcbiAgICAgICAgICAgICAgLnRoZW4ocmVzb2x2ZSlcbiAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlckFsbCh0ZW1wbGF0ZSwgbG9jYWxzID0ge30sIG1lc3NhZ2UgPSB7fSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc3ViamVjdFRlbXBsYXRlRXhpc3RzID0gdGhpcy5jb25maWcuY3VzdG9tUmVuZGVyO1xuICAgICAgICBsZXQgaHRtbFRlbXBsYXRlRXhpc3RzID0gdGhpcy5jb25maWcuY3VzdG9tUmVuZGVyO1xuICAgICAgICBsZXQgdGV4dFRlbXBsYXRlRXhpc3RzID0gdGhpcy5jb25maWcuY3VzdG9tUmVuZGVyO1xuXG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gW1xuICAgICAgICAgIHRoaXMudGVtcGxhdGVFeGlzdHMoYCR7dGVtcGxhdGV9L3N1YmplY3RgKSxcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlRXhpc3RzKGAke3RlbXBsYXRlfS9odG1sYCksXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZUV4aXN0cyhgJHt0ZW1wbGF0ZX0vdGV4dGApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHRlbXBsYXRlICYmICF0aGlzLmNvbmZpZy5jdXN0b21SZW5kZXIpXG4gICAgICAgICAgW1xuICAgICAgICAgICAgc3ViamVjdFRlbXBsYXRlRXhpc3RzLFxuICAgICAgICAgICAgaHRtbFRlbXBsYXRlRXhpc3RzLFxuICAgICAgICAgICAgdGV4dFRlbXBsYXRlRXhpc3RzXG4gICAgICAgICAgXSA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcblxuICAgICAgICBpZiAoIW1lc3NhZ2Uuc3ViamVjdCAmJiBzdWJqZWN0VGVtcGxhdGVFeGlzdHMpIHtcbiAgICAgICAgICBtZXNzYWdlLnN1YmplY3QgPSBhd2FpdCB0aGlzLnJlbmRlcihcbiAgICAgICAgICAgIGAke3RlbXBsYXRlfS9zdWJqZWN0YCxcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oe30sIGxvY2FscywgeyBwcmV0dHk6IGZhbHNlIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtZXNzYWdlLnN1YmplY3QgPSBtZXNzYWdlLnN1YmplY3QudHJpbSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2Uuc3ViamVjdCAmJiB0aGlzLmNvbmZpZy5zdWJqZWN0UHJlZml4KVxuICAgICAgICAgIG1lc3NhZ2Uuc3ViamVjdCA9IHRoaXMuY29uZmlnLnN1YmplY3RQcmVmaXggKyBtZXNzYWdlLnN1YmplY3Q7XG5cbiAgICAgICAgaWYgKCFtZXNzYWdlLmh0bWwgJiYgaHRtbFRlbXBsYXRlRXhpc3RzKVxuICAgICAgICAgIG1lc3NhZ2UuaHRtbCA9IGF3YWl0IHRoaXMucmVuZGVyKGAke3RlbXBsYXRlfS9odG1sYCwgbG9jYWxzKTtcblxuICAgICAgICBpZiAoIW1lc3NhZ2UudGV4dCAmJiB0ZXh0VGVtcGxhdGVFeGlzdHMpXG4gICAgICAgICAgbWVzc2FnZS50ZXh0ID0gYXdhaXQgdGhpcy5yZW5kZXIoXG4gICAgICAgICAgICBgJHt0ZW1wbGF0ZX0vdGV4dGAsXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHt9LCBsb2NhbHMsIHsgcHJldHR5OiBmYWxzZSB9KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmh0bWxUb1RleHQgJiYgbWVzc2FnZS5odG1sICYmICFtZXNzYWdlLnRleHQpXG4gICAgICAgICAgLy8gd2UnZCB1c2Ugbm9kZW1haWxlci1odG1sLXRvLXRleHQgcGx1Z2luXG4gICAgICAgICAgLy8gYnV0IHdlIHJlYWxseSBkb24ndCBuZWVkIHRvIHN1cHBvcnQgY2lkXG4gICAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyaXM5L25vZGVtYWlsZXItaHRtbC10by10ZXh0PlxuICAgICAgICAgIG1lc3NhZ2UudGV4dCA9IGh0bWxUb1RleHQuZnJvbVN0cmluZyhcbiAgICAgICAgICAgIG1lc3NhZ2UuaHRtbCxcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmh0bWxUb1RleHRcbiAgICAgICAgICApO1xuXG4gICAgICAgIC8vIGlmIHdlIG9ubHkgd2FudCBhIHRleHQtYmFzZWQgdmVyc2lvbiBvZiB0aGUgZW1haWxcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLnRleHRPbmx5KSBkZWxldGUgbWVzc2FnZS5odG1sO1xuXG4gICAgICAgIHJlc29sdmUobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBzZW5kKG9wdGlvbnMgPSB7fSkge1xuICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKFxuICAgICAge1xuICAgICAgICB0ZW1wbGF0ZTogJycsXG4gICAgICAgIG1lc3NhZ2U6IHt9LFxuICAgICAgICBsb2NhbHM6IHt9XG4gICAgICB9LFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICBsZXQgeyB0ZW1wbGF0ZSwgbWVzc2FnZSwgbG9jYWxzIH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgYXR0YWNobWVudHMgPVxuICAgICAgbWVzc2FnZS5hdHRhY2htZW50cyB8fCB0aGlzLmNvbmZpZy5tZXNzYWdlLmF0dGFjaG1lbnRzIHx8IFtdO1xuXG4gICAgbWVzc2FnZSA9IF8uZGVmYXVsdHNEZWVwKFxuICAgICAge30sXG4gICAgICBfLm9taXQodGhpcy5jb25maWcubWVzc2FnZSwgJ2F0dGFjaG1lbnRzJyksXG4gICAgICBfLm9taXQobWVzc2FnZSwgJ2F0dGFjaG1lbnRzJylcbiAgICApO1xuICAgIGxvY2FscyA9IF8uZGVmYXVsdHNEZWVwKHt9LCB0aGlzLmNvbmZpZy52aWV3cy5sb2NhbHMsIGxvY2Fscyk7XG5cbiAgICBpZiAoYXR0YWNobWVudHMpIG1lc3NhZ2UuYXR0YWNobWVudHMgPSBhdHRhY2htZW50cztcblxuICAgIGRlYnVnKCd0ZW1wbGF0ZSAlcycsIHRlbXBsYXRlKTtcbiAgICBkZWJ1ZygnbWVzc2FnZSAlTycsIG1lc3NhZ2UpO1xuICAgIGRlYnVnKCdsb2NhbHMgKGtleXMgb25seSk6ICVPJywgT2JqZWN0LmtleXMobG9jYWxzKSk7XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZ2V0IGFsbCBhdmFpbGFibGUgdGVtcGxhdGVzXG4gICAgICAgIGNvbnN0IG9iaiA9IGF3YWl0IHRoaXMucmVuZGVyQWxsKHRlbXBsYXRlLCBsb2NhbHMsIG1lc3NhZ2UpO1xuXG4gICAgICAgIC8vIGFzc2lnbiB0aGUgb2JqZWN0IHZhcmlhYmxlcyBvdmVyIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWVzc2FnZSwgb2JqKTtcblxuICAgICAgICBpZiAodGhpcy5jb25maWcucHJldmlldykge1xuICAgICAgICAgIGRlYnVnKCd1c2luZyBgcHJldmlldy1lbWFpbGAgdG8gcHJldmlldyBlbWFpbCcpO1xuICAgICAgICAgIGF3YWl0IHByZXZpZXdFbWFpbChtZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jb25maWcuc2VuZCkge1xuICAgICAgICAgIGRlYnVnKCdzZW5kIGRpc2FibGVkIHNvIHdlIGFyZSBlbnN1cmluZyBKU09OVHJhbnNwb3J0Jyk7XG4gICAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlbWFpbGVyL25vZGVtYWlsZXIvaXNzdWVzLzc5OD5cbiAgICAgICAgICAvLyBpZiAodGhpcy5jb25maWcudHJhbnNwb3J0Lm5hbWUgIT09ICdKU09OVHJhbnNwb3J0JylcbiAgICAgICAgICB0aGlzLmNvbmZpZy50cmFuc3BvcnQgPSBub2RlbWFpbGVyLmNyZWF0ZVRyYW5zcG9ydCh7XG4gICAgICAgICAgICBqc29uVHJhbnNwb3J0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmNvbmZpZy50cmFuc3BvcnQuc2VuZE1haWwobWVzc2FnZSk7XG4gICAgICAgIGRlYnVnKCdtZXNzYWdlIHNlbnQnKTtcbiAgICAgICAgcmVzLm9yaWdpbmFsTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEVtYWlsO1xuIl19